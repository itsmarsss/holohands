<!DOCTYPE html>
<html>
    <head>
        <title>Hand Tracking</title>
        <style>
            body {
                margin: 0;
                overflow: hidden;
                display: flex;
                justify-content: center;
                align-items: center;
                height: 100vh;
                background-color: black;
            }
            #container {
                position: relative;
                display: flex;
                justify-content: center;
                align-items: center;
                width: 100%;
                height: 100%;
            }
            #overlay {
                position: absolute;
                pointer-events: none;
            }
            #controls {
                position: absolute;
                top: 10px;
                left: 10px;
                z-index: 10;
                display: flex;
                flex-direction: column;
            }
            .control-group {
                margin-bottom: 10px;
            }
        </style>
    </head>
    <body>
        <div id="container">
            <video id="videoFeed" autoplay playsinline></video>
            <canvas id="overlay"></canvas>
            <div id="controls">
                <div class="control-group">
                    <input
                        type="text"
                        id="leftHandName"
                        placeholder="Left Hand Symbol Name"
                    />
                    <button onclick="saveHandSymbol('Left')">
                        Save Left Hand Symbol
                    </button>
                </div>
                <div class="control-group">
                    <input
                        type="text"
                        id="rightHandName"
                        placeholder="Right Hand Symbol Name"
                    />
                    <button onclick="saveHandSymbol('Right')">
                        Save Right Hand Symbol
                    </button>
                </div>
            </div>
        </div>

        <script>
            const video = document.getElementById("videoFeed");
            const canvas = document.getElementById("overlay");
            const ctx = canvas.getContext("2d");
            const ws = new WebSocket("ws://" + window.location.host + "/ws");

            // Colors for different hands
            const handColors = {
                Left: "#FF0000", // Red
                Right: "#00FF00", // Green
            };

            const smoothingFactor = 0.5; // Adjust this value to control smoothing
            let previousPointerAngle = null; // Initialize previous angle variable
            let previousHandAngle = null; // Initialize previous angle variable
            let currentHandsData = []; // Store current hands data
            let drawnPoints = { Left: [], Right: [] }; // Store drawn points for each hand
            let isDrawing = { Left: false, Right: false }; // Track drawing state for each hand

            function resizeCanvas() {
                const aspectRatio = 640 / 480;
                const windowAspectRatio =
                    window.innerWidth / window.innerHeight;

                if (windowAspectRatio > aspectRatio) {
                    canvas.width = window.innerHeight * aspectRatio;
                    canvas.height = window.innerHeight;
                } else {
                    canvas.width = window.innerWidth;
                    canvas.height = window.innerWidth / aspectRatio;
                }

                canvas.style.width = canvas.width + "px";
                canvas.style.height = canvas.height + "px";
            }

            function drawHand(hand, imgWidth, imgHeight) {
                console.log(hand);

                // Scale coordinates to video feed size
                const scaleX = canvas.width / imgWidth;
                const scaleY = canvas.height / imgHeight;

                // Draw connections
                ctx.strokeStyle = handColors[hand.handedness];
                ctx.lineWidth = 2;
                hand.connections.forEach(([start, end]) => {
                    const startX = hand.landmarks[start][0] * scaleX;
                    const startY = hand.landmarks[start][1] * scaleY;
                    const endX = hand.landmarks[end][0] * scaleX;
                    const endY = hand.landmarks[end][1] * scaleY;

                    ctx.beginPath();
                    ctx.moveTo(startX, startY);
                    ctx.lineTo(endX, endY);
                    ctx.stroke();
                });

                // Draw landmarks
                ctx.fillStyle = handColors[hand.handedness];
                hand.landmarks.forEach((lm) => {
                    ctx.beginPath();
                    ctx.arc(lm[0] * scaleX, lm[1] * scaleY, 3, 0, 2 * Math.PI);
                    ctx.fill();
                });

                // Draw distance and angle between index finger and thumb
                const indexFinger = hand.landmarks[8];
                const thumb = hand.landmarks[4];
                const distance = Math.sqrt(
                    Math.pow((indexFinger[0] - thumb[0]) * scaleX, 2) +
                        Math.pow((indexFinger[1] - thumb[1]) * scaleY, 2)
                );

                const currentPointerAngle =
                    Math.atan2(
                        (indexFinger[1] - thumb[1]) * scaleY,
                        (indexFinger[0] - thumb[0]) * scaleX
                    ) *
                    (180 / Math.PI);

                // Smooth the angle using exponential moving average
                const pointerAngle =
                    previousPointerAngle === null
                        ? currentPointerAngle
                        : previousPointerAngle * (1 - smoothingFactor) +
                          currentPointerAngle * smoothingFactor;

                // Update the previous angle
                previousPointerAngle = pointerAngle;

                ctx.strokeStyle = "#0000FF"; // Blue for line
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(indexFinger[0] * scaleX, indexFinger[1] * scaleY);
                ctx.lineTo(thumb[0] * scaleX, thumb[1] * scaleY);
                ctx.stroke();

                ctx.fillStyle = "#0000FF"; // Blue for text
                ctx.font = "16px Arial";
                ctx.fillText(
                    distance.toFixed(2) +
                        "px, " +
                        -pointerAngle.toFixed(2) +
                        "°",
                    (indexFinger[0] * scaleX + thumb[0] * scaleX) / 2,
                    (indexFinger[1] * scaleY + thumb[1] * scaleY) / 2
                );

                // Print "<Hand> - hold" if distance is less than 50 pixels
                if (distance < 50) {
                    ctx.fillText(
                        `${hand.handedness} - hold`,
                        (indexFinger[0] * scaleX + thumb[0] * scaleX) / 2,
                        (indexFinger[1] * scaleY + thumb[1] * scaleY) / 2 + 20
                    );
                    console.log(`${hand.handedness} - hold`);

                    // Draw on the canvas
                    const cursorX = ((indexFinger[0] + thumb[0]) / 2) * scaleX;
                    const cursorY = ((indexFinger[1] + thumb[1]) / 2) * scaleY;
                    if (!isDrawing[hand.handedness]) {
                        drawnPoints[hand.handedness].push([]);
                        isDrawing[hand.handedness] = true;
                    }
                    drawnPoints[hand.handedness][
                        drawnPoints[hand.handedness].length - 1
                    ].push({ x: cursorX, y: cursorY });
                } else {
                    isDrawing[hand.handedness] = false;
                }

                // Draw cursor (midpoint between index finger and thumb)
                const cursorX = ((indexFinger[0] + thumb[0]) / 2) * scaleX;
                const cursorY = ((indexFinger[1] + thumb[1]) / 2) * scaleY;
                ctx.fillStyle = "#FFFF00"; // Yellow for cursor
                ctx.beginPath();
                ctx.arc(cursorX, cursorY, 5, 0, 2 * Math.PI);
                ctx.fill();

                // Calculate and draw the angle of the entire hand
                const wrist = hand.landmarks[0];
                const middleFingerMCP = hand.landmarks[9];
                const ringFingerMCP = hand.landmarks[13];

                // Calculate the midpoint of the two MCPs
                const midpointMCP = [
                    (middleFingerMCP[0] + ringFingerMCP[0]) / 2,
                    (middleFingerMCP[1] + ringFingerMCP[1]) / 2,
                ];

                ctx.strokeStyle = "#00FFFF"; // Cyan for line
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(midpointMCP[0] * scaleX, midpointMCP[1] * scaleY);
                ctx.lineTo(wrist[0] * scaleX, wrist[1] * scaleY);
                ctx.stroke();

                // Calculate the angle between the wrist and the midpoint of the MCPs
                const currentHandAngle = Math.atan2(
                    (midpointMCP[1] - wrist[1]) * scaleY,
                    (midpointMCP[0] - wrist[0]) * scaleX
                );

                // Smooth the angle using exponential moving average
                const handAngle =
                    previousHandAngle === null
                        ? currentHandAngle
                        : previousHandAngle * (1 - smoothingFactor) +
                          currentHandAngle * smoothingFactor;

                // Update the previous angle
                previousHandAngle = handAngle;

                ctx.fillStyle = "#FFFFFF"; // White for hand angle text
                ctx.fillText(
                    "Hand angle: " +
                        (-handAngle * (180 / Math.PI)).toFixed(2) +
                        "°",
                    wrist[0] * scaleX,
                    wrist[1] * scaleY - 10
                );

                // Draw detected symbols if applicable
                if (hand.detected_symbols && hand.detected_symbols.length > 0) {
                    console.log(hand.detected_symbols);
                    hand.detected_symbols.forEach((symbol, index) => {
                        ctx.fillText(
                            `${symbol[0]} (${(symbol[1] * 100).toFixed(2)}%)`,
                            wrist[0] * scaleX,
                            wrist[1] * scaleY + 20 + index * 20
                        );
                    });
                }
            }

            function drawPoints() {
                ctx.strokeStyle = "#FF0000"; // Red for left hand drawn lines
                ctx.lineWidth = 2;
                drawnPoints.Left.forEach((stroke) => {
                    for (let i = 1; i < stroke.length; i++) {
                        ctx.beginPath();
                        ctx.moveTo(stroke[i - 1].x, stroke[i - 1].y);
                        ctx.lineTo(stroke[i].x, stroke[i].y);
                        ctx.stroke();
                    }
                });

                ctx.strokeStyle = "#00FF00"; // Green for right hand drawn lines
                ctx.lineWidth = 2;
                drawnPoints.Right.forEach((stroke) => {
                    for (let i = 1; i < stroke.length; i++) {
                        ctx.beginPath();
                        ctx.moveTo(stroke[i - 1].x, stroke[i - 1].y);
                        ctx.lineTo(stroke[i].x, stroke[i].y);
                        ctx.stroke();
                    }
                });
            }

            // Update the message handler
            ws.onmessage = (event) => {
                const data = JSON.parse(event.data);
                ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear canvas before drawing
                ctx.save();
                ctx.scale(-1, 1); // Reflect the canvas horizontally
                ctx.drawImage(
                    video,
                    -canvas.width,
                    0,
                    canvas.width,
                    canvas.height
                );
                ctx.restore();

                if (data.hands.length > 0) {
                    currentHandsData = data.hands; // Store current hands data
                    data.hands.forEach((hand) => {
                        drawHand(
                            hand,
                            data.image_size.width,
                            data.image_size.height
                        );
                    });
                }

                // Draw previously drawn points
                drawPoints();
            };

            // Handle window resize
            window.addEventListener("resize", resizeCanvas);
            resizeCanvas(); // Initial resize

            // Stream webcam data to the backend
            navigator.mediaDevices
                .getUserMedia({ video: true })
                .then((stream) => {
                    video.srcObject = stream;
                    video.onloadedmetadata = () => {
                        video.play();
                        const sendFrame = () => {
                            const offscreenCanvas =
                                document.createElement("canvas");
                            offscreenCanvas.width = video.videoWidth;
                            offscreenCanvas.height = video.videoHeight;
                            const offscreenCtx =
                                offscreenCanvas.getContext("2d");
                            offscreenCtx.scale(-1, 1); // Reflect the video feed horizontally
                            offscreenCtx.drawImage(
                                video,
                                -offscreenCanvas.width,
                                0,
                                offscreenCanvas.width,
                                offscreenCanvas.height
                            );
                            ws.send(offscreenCanvas.toDataURL("image/webp", 1)); // Use WebP format with 75% quality
                            setTimeout(sendFrame, 33); // Aim for ~30 FPS
                        };
                        sendFrame();
                    };
                });

            function saveHandSymbol(handedness) {
                const name = document.getElementById(
                    handedness === "Left" ? "leftHandName" : "rightHandName"
                ).value;
                if (!name) {
                    alert("Please enter a name for the hand symbol.");
                    return;
                }

                // Find the hand data for the specified handedness
                const handData = currentHandsData.find(
                    (hand) => hand.handedness === handedness
                );
                if (!handData) {
                    alert(`No ${handedness} hand detected.`);
                    return;
                }

                // Send the hand data to the server
                fetch("/save_handsymbol", {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json",
                    },
                    body: JSON.stringify({
                        name: name,
                        handedness: handedness,
                        landmarks: handData.landmarks,
                    }),
                })
                    .then((response) => response.json())
                    .then((data) => {
                        if (data.status === "success") {
                            alert(
                                `${handedness} hand symbol saved successfully.`
                            );
                        } else {
                            alert(`Failed to save ${handedness} hand symbol.`);
                        }
                    })
                    .catch((error) => {
                        console.error("Error:", error);
                        alert(`Failed to save ${handedness} hand symbol.`);
                    });
            }
        </script>
    </body>
</html>
